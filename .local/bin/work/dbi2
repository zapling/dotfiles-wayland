#!/usr/bin/env bash

set -e # Exit the script on error
set -m # Run all jobs in their own process group

target=${1:-}

if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    printf "Usage: dbi2 <cluster-name>\n"
    printf "dbi2 is an helper to connect to postgres databases operated by cloudnative-pg.\n"
    printf "Example:\n"
    printf "\tdbi2\n"
    printf "\tdbi2 postgres-cluster\n"
    exit
fi

if ! type "python" > /dev/null; then
    echo "This script requires python"
    exit 1
fi

if ! type "docker" > /dev/null; then
    echo "This script requires docker"
    exit 1
fi

if ! type "kubectl" > /dev/null; then
    echo "This script requires kubectl"
    exit 1
fi

if [[ "$KUBECONFIG" == "" ]]; then
    echo "No KUBECONFIG env var set"
    exit 1
fi

clusters=($(kubectl get clusters -n db -o=jsonpath='{.items[].metadata.name}'))

if [[ ${#clusters[@]} -eq 1 ]] && [[ "$target" == "" ]]; then
    target="${clusters[0]}"
elif [[ ${#clusters[@]} -gt 1 ]] && [[ "$target" == "" ]]; then
    echo "Multiple clusters detected, please specify cluster."
    echo "Detected clusters:"
    for cluster in "${clusters[@]}"
    do
        printf "\t%s\n" "$cluster"
    done
    exit 1
fi

imageName=$(kubectl get clusters -n db "$target" -o=jsonpath='{.spec.imageName}')

if [ -z "$(docker images -q "$imageName" 2> /dev/null)" ]; then
    docker pull "$imageName"
fi

credentials=$(kubectl get secrets -n db "${target}-superuser" --template='{{.data.username}},{{.data.password}},{{.data.port}},{{.data.dbname}}')
IFS=, read pg_username pg_password pg_port pg_dbname <<< "$credentials"

pg_username=$(echo "$pg_username" | base64 -d)
pg_password=$(echo "$pg_password" | base64 -d)
pg_port=$(echo "$pg_port" | base64 -d)
pg_dbname=$(echo "$pg_dbname" | base64 -d)

# Get a random available port
local_port=$(python -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()');

connection_string="postgresql://$pg_username:$pg_password@localhost:$local_port"

service="services/${target}-rw"
cmd="kubectl port-forward -n db $service $local_port:$pg_port"
echo "Port forwarding localhost:$local_port => $service:$pg_port"
eval "$cmd > /dev/null 2>&1 &"

# Ensure that the port forward is killed when script exits
trap '{
    pkill -f "$cmd"
}' EXIT

# Wait for port forward
sleep 1

tmp_dir="/tmp/.psql-dbi-${local_port}"
mkdir -p "$tmp_dir"

psqlrc="${tmp_dir}/.psqlrc"

if [[ -e ~/.psqlrc ]]; then
    cp ~/.psqlrc "$psqlrc"
fi

prefix="${service//services\//}"

cat << EOF >> "$psqlrc"
\set PROMPT1 '($prefix) %/%R%x%# '
EOF

docker run \
    --network="host" \
    -v "${tmp_dir}:/data" \
    -it "$imageName" bash -c "PSQLRC=/data/.psqlrc psql $connection_string"
